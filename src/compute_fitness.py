from include.mujocoSimulator.mujocoSimulator import MujocoSimulator
from include.robotModel.robotModel import RobotModel
from include.centroidalMPC.centroidalMPC import CentroidalMPC
from include.centroidalMPC.mpcParameterTuning import MPCParameterTuning
from include.TSIDController.TSIDParameterTuning import TSIDParameterTuning
from include.inverseKinematic.inverseKinematicParamTuning import InverseKinematicParamTuning
import os
import xml.etree.ElementTree as ET
from include.inverseKinematic.inverseKinematic import inverseKinematic
import numpy as np 
from datetime import timedelta
import time 

def matrix_to_rpy(matrix):
    """Converts a rotation matrix to roll, pitch, and yaw angles in radians.

    Args:
        matrix (numpy.ndarray): 3x3 rotation matrix.

    Returns:
        tuple: Tuple containing the roll, pitch, and yaw angles in radians.
    """
    assert matrix.shape == (3, 3), "Input matrix must be a 3x3 rotation matrix."

    # Extract rotation angles from the rotation matrix
    yaw = np.arctan2(matrix[1, 0], matrix[0, 0])
    pitch = np.arctan2(-matrix[2, 0], np.sqrt(matrix[2, 1]**2 + matrix[2, 2]**2))
    roll = np.arctan2(matrix[2, 1], matrix[2, 2])
    rpy = np.zeros(3)
    rpy[0] = roll
    rpy[1] = pitch
    rpy[2] = yaw
    return rpy



## Defining the urdf path of both the startin, del and the modified one
common_path = os.path.dirname(os.path.abspath(__file__))
urdf_path_original = common_path + "/models/urdf/ergoCub/robots/ergoCubSN000/model.urdf"
mujoco_path = common_path+ "/models/urdf/ergoCub/robots/ergoCubSN000/muj_model.xml"
# Load the URDF file
tree = ET.parse(urdf_path_original)
root = tree.getroot()

# Convert the XML tree to a string
robot_urdf_string_original = ET.tostring(root)

# World urdf path
word_path = common_path + "/autogenerated/model_modified.world"
data_base_name = common_path + "/results/database"

# Instantiating Robot Model 
robot_model_init = RobotModel(robot_urdf_string_original, word_path)

# Defining initial robot configuration 
s_des = np.array( [ 0.56056952, 0.01903913, -0.0172335, -1.2220763, -0.52832664, -0.02720832, 0.56097981, 0.0327311 ,-0.02791293,-1.22200495,  -0.52812215, -0.04145696,0.02749586, 0.25187149, -0.14300417, 0.6168618, 0.03145343, 0.25644825, -0.14427671, 0.61634549,])

contact_frames_pose = {robot_model_init.left_foot_frame: np.eye(4),robot_model_init.right_foot_frame: np.eye(4)}
H_b = robot_model_init.get_base_pose_from_contacts(s_des, contact_frames_pose)
xyz_rpy = np.zeros(6)
xyz_rpy[:3] = H_b[:3,3]
rpy = matrix_to_rpy(H_b[:3,:3])
xyz_rpy[3:] = rpy 
energy_tot = 0 

def compute_fitness(x_k):
    ik_gain = x_k[:9]
    mpc_gains = x_k[9:]
    
    # Defining parameters
    mpc_parameters = MPCParameterTuning()
    mpc_parameters.set_from_xk(mpc_gains)
    ik_parameters = InverseKinematicParamTuning()
    ik_parameters.set_from_xk(ik_gain)

    # Defining IK instance
    IK_controller_instance = inverseKinematic(frequency=0.01,robot_model=robot_model_init)
    IK_controller_instance.define_tasks(parameters=ik_parameters)

    # Defining MPC 
    mpc = CentroidalMPC(robot_model=robot_model_init)

    # Defining the simulator 
    mujoco_instance = MujocoSimulator()
    mujoco_instance.load_model(robot_model_init, s= s_des, xyz_rpy=xyz_rpy, mujoco_path=mujoco_path)
    s,ds,tau = mujoco_instance.get_state()
    t = mujoco_instance.get_simulation_time()
    H_b = mujoco_instance.get_base()
    w_b = mujoco_instance.get_base_velocity()
    
    IK_controller_instance.set_state_with_base(s,ds,H_b,w_b,t)
    
    n_step = int(IK_controller_instance.frequency/mujoco_instance.get_simulation_frequency())
    n_step_mpc_tsid = int(mpc.get_frequency_seconds()/IK_controller_instance.frequency)

    
    mpc.intialize_mpc(mpc_parameters=mpc_parameters)
    mpc.configure(s_init=s_des, H_b_init=H_b)
    mpc.define_test_com_traj()
    TIME_TH = 20
    mujoco_instance.set_visualize_robot_flag(True)
    mujoco_instance.step(1)
    s,ds,tau = mujoco_instance.get_state()
    
    H_b = mujoco_instance.get_base()
    w_b = mujoco_instance.get_base_velocity()
    t = mujoco_instance.get_simulation_time()
    mpc.set_state_with_base(s=s, s_dot=ds, H_b=H_b, w_b=w_b,t=t)
    mpc.initialize_centroidal_integrator(s=s, s_dot=ds,H_b=H_b, w_b=w_b,t=t)
    mpc_output = mpc.plan_trajectory()  

    # Update MPC and getting the state
    mpc.set_state_with_base(s=s, s_dot=ds, H_b=H_b, w_b=w_b,t=t)
    IK_controller_instance.set_state_with_base(s,ds,H_b,w_b,t)
    IK_controller_instance.update_com(H_b, s)
    IK_controller_instance.set_desired_base_orientation()
    counter = 0 
    mpc_success = True
    succeded_controller = True
    energy_tot = 0.0
    IK_controller_instance.define_integrator()
    
    while(t<TIME_TH):
        robot_standing = True 
        # Reading robot state from simulator
        s,ds,tau = mujoco_instance.get_state()
        energy_i = -1*np.linalg.norm(tau) # negative since we want to maximize the fitness 
        H_b = mujoco_instance.get_base()

        if(H_b[2,3]<0.5): 
            robot_standing = False
            print("Robot felt")
            break
        
        w_b = mujoco_instance.get_base_velocity()
        t = mujoco_instance.get_simulation_time()
        
        if(counter == 0):
            mpc.set_state_with_base(s=s, s_dot=ds, H_b=H_b, w_b=w_b,t=t)
            mpc.update_references()
            mpc_success = mpc.plan_trajectory()
            mpc.contact_planner.advance_swing_foot_planner()
            if(not(mpc_success)): 
                print("MPC failed")
                break

        com, dcom,forces_left, forces_right, ang_mom = mpc.get_references()
        left_foot, right_foot = mpc.contact_planner.get_references_swing_foot_planner()
        left_foot_front_wrench, left_foot_rear_wrench, rigth_foot_front_wrench, rigth_foot_rear_wrench = mujoco_instance.get_feet_wrench()
        IK_controller_instance.compute_zmp(left_foot_front_wrench, left_foot_rear_wrench, rigth_foot_front_wrench, rigth_foot_rear_wrench)
        IK_controller_instance.update_task_references_mpc(com=com, dcom=dcom,ddcom=np.zeros(3),left_foot_desired=left_foot, right_foot_desired=right_foot,s_desired=np.array(s_des), wrenches_left = forces_left, wrenches_right = forces_right, H_omega=ang_mom)
        succeded_controller = IK_controller_instance.run()
        IK_controller_instance.update_state()
        IK_controller_instance.update_com(H_b, s) 
        if(not(succeded_controller)): 
            print("Controller failed")
            break
        
        s_ctrl = IK_controller_instance.get_output()
        mujoco_instance.set_position_input(s_ctrl)
        mujoco_instance.step(n_step=n_step)
        counter = counter+ 1 

        if(counter == n_step_mpc_tsid): 
            counter = 0 
        energy_tot+= energy_i
    succed_overall = succeded_controller and mpc_success and robot_standing
    return energy_tot, succed_overall


## Definition of x_k 

# IK parameters
zmp_gain = np.asarray([0.2,0.2]) #interval [0.1-2.0]
com_gain = np.asarray([2.0,2.0]) #interval [0.5,5.0]
foot_linear = np.asarray([3.0]) #interval [1,5.0]
foot_angular = np.asarray([9.0]) #interval [2.0,10]
com_linear = np.asarray([2.0]) #interval [1,5.0]
chest_angular = np.asarray([1.0]) #interval [1,10]
root_linear = np.asarray([2.0]) # interval [1.0,5.0]
ik_param = np.concatenate((zmp_gain, com_gain, foot_linear, foot_angular, com_linear, chest_angular, root_linear))

# MPC Parameters
# In the interval (0,1000]
com_weight = np.asarray([10,10,200]) # from 0-2
contact_position_weight = np.asarray([1e3])/1e1 # 3
force_rate_change_weight =np.asarray([10.0,10.0,10.0])/1e2 # from 4-6
angular_momentum_weight = np.asarray([1e5])/1e3 # 7 
contact_force_symmetry_weight = np.asarray([1.0])/1e2
mpc_param = np.concatenate((com_weight, contact_position_weight, force_rate_change_weight, angular_momentum_weight,contact_force_symmetry_weight))
#x_k = np.concatenate((ik_param, mpc_param))
#1.2889258871515765,0.2458297907075273,2.942536617550875,2.5389832900601563,0.8742642018980291,8.322494482051694,1.7262494098269032,0.6614784491224647,0.31206567693843423,10.835770889039075,10.653292045129,198.47024705293674,100.13890959109565,0.8775546030509591,2.959582304307046,0.7776375819056551,101.99812060826484,0.8620332407118212
#x_k = np.array([1.2889258871515765,0.2458297907075273,2.942536617550875,2.5389832900601563,0.8742642018980291,8.322494482051694,1.7262494098269032,0.6614784491224647,0.31206567693843423,10.835770889039075,10.653292045129,198.47024705293674,100.13890959109565,0.8775546030509591,2.959582304307046,0.7776375819056551,101.99812060826484,0.8620332407118212])
#x_k = np.array([1.724423992721494,0.22301078125734455,1.689035268262418,2.3810621794593874,3.3227923508362003,9.040891455399167,1.4917329110163522,1.404698199763498,3.112722383315396,9.933139278881443,10.058835734080892,200.7778927743194,99.86994821430245,2.2534692705758514,0.12487934066783234,1.433074296057167,100.27580519044787,1.521705446261305])
#x_k = np.array([1.4999999999999993,1.8599999999999992,1.700000000000001,2.760000000000002,2.9400000000000017,8.361767221887877,4.220000000000002,1.670502831582585,2.120000000000001,9.935248610822144,10.046696535214108,290.0,349.5,173.0,511.5,1.4274681005772034,100.28777944112312,127.0])

#x_k = np.array([0.1, 0.1,2.1504690719122896,3.2906393475003552,1.0,3.58026193132222,5.0,1.0, 4.345019194764908,5.119064082185511,69.274813960178,128.82964973576057, 234.8734366509351,165.4325055522369,872.4118881726101,49.37846910036437, 693.4744092448602,133.1500773058204])

# x_k = np.array([1.9000000000000001, 0.6,
#  2.6999999999999993, 0.7290573548669658,
#  1.0, 5.399999999999999,4.4812099619929455,
#  0.6130756546665379, 2.9999999999999996, 5.552295504868113,
#  68.41541384089166, 406.0, 683.5101006534087, 5.5,
#  954.5, 48.0,692.0, 555.0])
#x_k = np.array([1.7000000000000002,1.3888811265035017,2.6999999999999993,1.933440116579302,1.0,2.9999999999999996,4.268694355891118,0.6130756546665379,2.963512591038024,5.5,68.5,406.0,234.0,5.5,872.5,48.0,692.0,717.5])

x_k = np.array([1.6715576625181272,1.5714490631590634,2.6107372889578864,1.8999999999999997,1.0,2.9999999999999996,4.234949979462621,0.6130756546665379,2.9999999999999996,5.5406743603314785,68.5,406.0,233.97962258859195,5.5,872.5551937071568,47.988608847977424,691.9528691266194,717.5])
# Fitness Computation
print(x_k)
values, stats = [], [] 
for _ in range(1):
    t_start = time.time()
    f_k , status= compute_fitness(x_k)
    t_end = time.time()
    values.append(f_k)
    stats.append(status)
    
print("mu, std  ",np.mean(values), np.std(values))
print("mu, std  ",np.mean(stats), np.std(stats), stats)
print("elapsed time", t_end-t_start)
print("f(x_k)=",f_k)
print("succeded = ", status)
