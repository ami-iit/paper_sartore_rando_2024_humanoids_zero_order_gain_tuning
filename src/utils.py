from include.mujocoSimulator.mujocoSimulator import MujocoSimulator
from include.robotModel.robotModel import RobotModel
from include.centroidalMPC.centroidalMPC import CentroidalMPC
from include.centroidalMPC.mpcParameterTuning import MPCParameterTuning
from include.TSIDController.TSIDParameterTuning import TSIDParameterTuning
from include.inverseKinematic.inverseKinematicParamTuning import InverseKinematicParamTuning
from dataBaseFitnessFunction import DatabaseFitnessFunction
import os
import xml.etree.ElementTree as ET
from include.inverseKinematic.inverseKinematic import inverseKinematic
import numpy as np 
import datetime
from datetime import timedelta
import time 

from concurrent.futures import ProcessPoolExecutor as PPE


def load_init_population(fpath):
    data = np.load(fpath, allow_pickle=True)
    X, Y = [], []
    for elem in data:
        x = np.concatenate([elem[:8], elem[9:]])
        X.append(x)
        Y.append(elem[-1])
    return X, Y
    # X, Y = [], []
    # with open(fpath, 'r') as f:
    #     lines = f.readlines()
    #     for line in lines:
    #         splitted = line.split(",")
    #         x = np.array([float(x) for x in splitted[:-1]],dtype=np.float32)
    #         y = float(splitted[-1])
    #         X.append(x)
    #         Y.append(y)
    # return X, Y  

def matrix_to_rpy(matrix):
    """Converts a rotation matrix to roll, pitch, and yaw angles in radians.

    Args:
        matrix (numpy.ndarray): 3x3 rotation matrix.

    Returns:
        tuple: Tuple containing the roll, pitch, and yaw angles in radians.
    """
    assert matrix.shape == (3, 3), "Input matrix must be a 3x3 rotation matrix."

    # Extract rotation angles from the rotation matrix
    yaw = np.arctan2(matrix[1, 0], matrix[0, 0])
    pitch = np.arctan2(-matrix[2, 0], np.sqrt(matrix[2, 1]**2 + matrix[2, 2]**2))
    roll = np.arctan2(matrix[2, 1], matrix[2, 2])
    rpy = np.zeros(3)
    rpy[0] = roll
    rpy[1] = pitch
    rpy[2] = yaw
    return rpy

def clip_input(x_k, min_param, max_param): 
    len_xk = len(x_k)
    for idx in range(len_xk): 
        el = x_k[idx]
        min_el = min_param[idx]
        max_el = max_param[idx]
        if(el<min_el): 
            x_k[idx] = min_el
        elif(el>max_el): 
            x_k[idx] = max_el
    return x_k 

## Defining global variables

## Defining the urdf path of both the startin, del and the modified one
common_path = os.path.dirname(os.path.abspath(__file__))
urdf_path_original = common_path + "/models/urdf/ergoCub/robots/ergoCubSN000/model.urdf"
mujoco_path = common_path+ "/models/urdf/ergoCub/robots/ergoCubSN000/muj_model.xml"
# Load the URDF file
tree = ET.parse(urdf_path_original)
root = tree.getroot()

# Convert the XML tree to a string
robot_urdf_string_original = ET.tostring(root)

# World urdf path
word_path = common_path + "/autogenerated/model_modified.world"
data_base_name = common_path + "/results/database"

# Instantiating Robot Model 
robot_model_init = RobotModel(robot_urdf_string_original, word_path)

# Defining initial robot configuration 
s_des = np.array( [ 0.56056952, 0.01903913, -0.0172335, -1.2220763, -0.52832664, -0.02720832, 0.56097981, 0.0327311 ,-0.02791293,-1.22200495,  -0.52812215, -0.04145696,0.02749586, 0.25187149, -0.14300417, 0.6168618, 0.03145343, 0.25644825, -0.14427671, 0.61634549,])

contact_frames_pose = {robot_model_init.left_foot_frame: np.eye(4),robot_model_init.right_foot_frame: np.eye(4)}
H_b = robot_model_init.get_base_pose_from_contacts(s_des, contact_frames_pose)
xyz_rpy = np.zeros(6)
xyz_rpy[:3] = H_b[:3,3]
rpy = matrix_to_rpy(H_b[:3,:3])
xyz_rpy[3:] = rpy 
energy_tot = 0 
dataBase_instance = DatabaseFitnessFunction(
    common_path + "/results/fitnessDatabase"
)


MPC_PARAM_LEN = 8
IK_PARAM_LEN = 9

## bounds used in the clip function     
mpc_min_weigths = 10.0*np.ones(MPC_PARAM_LEN-2)
mpc_max_weigths = 150*np.ones(MPC_PARAM_LEN-2)
mpc_min = np.concatenate((np.asanyarray([2.0,20.0]), mpc_min_weigths))
mpc_max = np.concatenate((np.asanyarray([20.0,150.0]), mpc_max_weigths))
ik_min = np.asarray([0.2,0.2,3.5,3.5,1.0,1.0,1.0,1.0,1.0])
ik_max = np.asarray([1.0,1.0,5.0,5.0,5.0,10.0,5.0,10.0,5.0])
max_param  = np.concatenate((ik_max, mpc_max))
min_param = np.concatenate((ik_min, mpc_min))
gen_size = 100

## Variable frequency 
frequency_seconds_ik = 0.01 
frequency_milliseconds_centroidal_mpc = 100
def compute_fitness(x_k):
    
    # x_k = clip_input(x_k, min_param, max_param)
    ik_gain = x_k[:9]
    mpc_gains = x_k[9:]
    fitness_value = dataBase_instance.get_fitness_value(chromosome=x_k)
    # if already computed fitness value returing the value in the database
    if fitness_value is not None:
        print("Already comptued fitness")
        return fitness_value
    # Defining parameters
    mpc_parameters = MPCParameterTuning()
    mpc_parameters.set_from_xk(mpc_gains)
    ik_parameters = InverseKinematicParamTuning()
    ik_parameters.set_from_xk(ik_gain)

    # Defining IK instance
    IK_controller_instance = inverseKinematic(frequency=frequency_seconds_ik,robot_model=robot_model_init)
    IK_controller_instance.define_tasks(parameters=ik_parameters)

    # Defining MPC 
    mpc = CentroidalMPC(robot_model=robot_model_init,frequency_ms = frequency_milliseconds_centroidal_mpc)

    # Defining the simulator 
    mujoco_instance = MujocoSimulator()
    mujoco_instance.load_model(robot_model_init, s= s_des, xyz_rpy=xyz_rpy, mujoco_path=mujoco_path)
    s,ds,tau = mujoco_instance.get_state()
    t = mujoco_instance.get_simulation_time()
    H_b = mujoco_instance.get_base()
    w_b = mujoco_instance.get_base_velocity()
    
    IK_controller_instance.set_state_with_base(s,ds,H_b,w_b,t)
    
    n_step = int(IK_controller_instance.frequency/mujoco_instance.get_simulation_frequency())
    n_step_mpc_tsid = int(mpc.get_frequency_seconds()/IK_controller_instance.frequency)

    
    mpc.intialize_mpc(mpc_parameters=mpc_parameters)
    mpc.configure(s_init=s_des, H_b_init=H_b)
    IK_controller_instance.update_com(H_b, s)
    mpc.define_test_com_traj(IK_controller_instance.com)
    TIME_TH = 20
    mujoco_instance.set_visualize_robot_flag(False)
    mujoco_instance.step(1)
    s,ds,tau = mujoco_instance.get_state()
    
    H_b = mujoco_instance.get_base()
    w_b = mujoco_instance.get_base_velocity()
    t = mujoco_instance.get_simulation_time()
    mpc.set_state_with_base(s=s, s_dot=ds, H_b=H_b, w_b=w_b,t=t)
    mpc.initialize_centroidal_integrator(s=s, s_dot=ds,H_b=H_b, w_b=w_b,t=t)
    mpc_output = mpc.plan_trajectory()  

    # Update MPC and getting the state
    mpc.set_state_with_base(s=s, s_dot=ds, H_b=H_b, w_b=w_b,t=t)
    IK_controller_instance.set_state_with_base(s,ds,H_b,w_b,t)
    IK_controller_instance.update_com(H_b, s)
    IK_controller_instance.set_desired_base_orientation()
    counter = 0 
    mpc_success = True
    succeded_controller = True
    energy_tot = 0.0
    IK_controller_instance.define_integrator()
    
    while(t<TIME_TH):
        robot_standing = True 
        # Reading robot state from simulator
        s,ds,tau = mujoco_instance.get_state()
        energy_i = -1*np.linalg.norm(tau) # negative since we want to maximize the fitness 
        H_b = mujoco_instance.get_base()

        if(H_b[2,3]<0.5): 
            robot_standing = False
            print("Robot felt")
            break
        
        w_b = mujoco_instance.get_base_velocity()
        t = mujoco_instance.get_simulation_time()
        
        if(counter == 0):
            mpc.set_state_with_base(s=s, s_dot=ds, H_b=H_b, w_b=w_b,t=t)
            mpc.update_references()
            mpc_success = mpc.plan_trajectory()
            mpc.contact_planner.advance_swing_foot_planner()
            if(not(mpc_success)): 
                print("MPC failed")
                break

        com, dcom,forces_left, forces_right, ang_mom = mpc.get_references()
        left_foot, right_foot = mpc.contact_planner.get_references_swing_foot_planner()
        left_foot_front_wrench, left_foot_rear_wrench, rigth_foot_front_wrench, rigth_foot_rear_wrench = mujoco_instance.get_feet_wrench()
        IK_controller_instance.compute_zmp(left_foot_front_wrench, left_foot_rear_wrench, rigth_foot_front_wrench, rigth_foot_rear_wrench)
        IK_controller_instance.update_task_references_mpc(com=com, dcom=dcom,ddcom=np.zeros(3),left_foot_desired=left_foot, right_foot_desired=right_foot,s_desired=np.array(s_des), wrenches_left = forces_left, wrenches_right = forces_right, H_omega=ang_mom)
        succeded_controller = IK_controller_instance.run()
        IK_controller_instance.update_state()
        IK_controller_instance.update_com(H_b, s) 
        if(not(succeded_controller)): 
            print("Controller failed")
            break
        
        s_ctrl = IK_controller_instance.get_output()
        mujoco_instance.set_position_input(s_ctrl)
        mujoco_instance.step(n_step=n_step)
        counter = counter+ 1 

        if(counter == n_step_mpc_tsid): 
            counter = 0 
        energy_tot+= energy_i

    succed_overall = succeded_controller and mpc_success and robot_standing
    
    if(succed_overall): 
        fitness = float(energy_tot) 
    else: 
        fitness = -1e1000
    
    # timestamp = datetime.datetime.timestamp(datetime.datetime.now())
    # dataBase_instance.update(x_k, fitness,int(succed_overall))
    return fitness


def execute_optimizer(opt, T = 100, max_workers=4, out_file = "./results.log"):
    with PPE(max_workers=max_workers) as executor:
        with open(out_file, 'w') as f:
            for t in range(T):
                population = opt.ask()
                X, Y = [], []
                for x, y in zip(population, executor.map(compute_fitness, population)):
                    X.append(x)
                    Y.append(-y)
                for i in range(len(X)):
                    f.write(",".join([str(X[i][j])  for j in range(X[i].shape[0])]) + f",{-Y[i]}\n")
                    f.flush()
                opt.tell(X, Y) 
    return opt.best